namespace Qx
{
//===============================================================================================================
// FreeIndexTracker
//===============================================================================================================

/*!
 *  @class FreeIndexTracker qx/core/qx-freeindextracker.h
 *  @ingroup qx-core
 *
 *  @brief The FreeIndexTracker template class tracks which slots from a given range of indices are in use and
 *  which are available.
 *
 *  The range of an index tracker can be expanded or contracted, and indices within that range can be reserved
 *  or released. An example use-case for this class might be tracking which spaces in a parking lot are free.
 *
 *  @warning
 */

//-Constructor----------------------------------------------------------------------------------------------
//Public:
/*!
 * @fn template <typename T> FreeIndexTracker<T>::FreeIndexTracker(T minIndex = 0, T maxIndex = 0, QSet<T> reservedIndices = QSet<T>())
 *
 *  Creates an index tracker for the range @a minIndex to @a maxIndex, with the indices from @a reservedIndices
 *  already reserved.
 *
 *  If @a maxIndex is -1, the upper bound of the range is set to std::numeric_limits<T>::max().
 *
 *  If any of the values within @a reservedIndices fall outside the range of @a minIndex:maxIndex, the range
 *  of the tracker will automatically be resized to cover them.
 *
 *  @warning @a minIndex must be greater than 0, and less than or equal to maxIndex or an assertion failure
 *  will occur!
 */

//-Class Functions--------------------------------------------------------------------------------------------
//Public:
/*!
 *  @fn template <typename T> bool FreeIndexTracker<T>::isReserved(T index) const
 *
 *  Returns @c true if @a index is occupied; otherwise returns @c false.
 */

/*!
 *  @fn template <typename T> T FreeIndexTracker<T>::minimum() const
 *
 *  Returns the lower bound of the index tracker.
 */

/*!
 *  @fn template <typename T> T FreeIndexTracker<T>::maximum() const
 *
 *  Returns the upper bound of the index tracker.
 */

/*!
 *  @fn template <typename T> T FreeIndexTracker<T>::firstReserved() const
 *
 *  Returns the lowest index that is currently reserved, or -1 if all are free.
 */

/*!
 *  @fn template <typename T> T FreeIndexTracker<T>::lastReserved() const
 *
 *  Returns the highest index that is currently reserved, or -1 if all are free.
 */

/*!
 *  @fn template <typename T> T FreeIndexTracker<T>::firstFree() const
 *
 *  Returns the lowest available index, or -1 if all are reserved.
 */

/*!
 *  @fn template <typename T> T FreeIndexTracker<T>::lastFree() const
 *
 *  Returns the highest available index, or -1 if all are reserved.
 */

/*!
 *  @fn template <typename T> bool FreeIndexTracker<T>::reserve(int index)
 *
 *  Attempts to mark @a index as occupied and returns @c true if successful, or @c false if the index was
 *  already reserved.
 */

/*!
 *  @fn template <typename T> T FreeIndexTracker<T>::reserveFirstFree()
 *
 *  Attempts to mark the lowest available index as occupied and return it if successful, or -1 if there
 *  are no free indices.
 */

/*!
 *  @fn template <typename T> T FreeIndexTracker<T>::reserveLastFree()
 *
 *  Attempts to mark the highest available index as occupied and return it if successful, or -1 if there
 *  are no free indices.
 */

/*!
 *  @fn template <typename T> bool FreeIndexTracker<T>::release(int index)
 *
 *  Attempts to mark @a index as unoccupied and returns @c true if successful, or @c false if the index was
 *  already free.
 */
}
