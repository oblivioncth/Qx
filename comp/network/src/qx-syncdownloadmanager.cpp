// Unit Includes
#include "qx/network/qx-syncdownloadmanager.h"

// Qt Includes
#include <QScopedValueRollback>
#include <QAuthenticator>
#include <QNetworkProxy>

// Extra-component Includes
#include "qx/core/qx-string.h"

namespace Qx
{
	
//===============================================================================================================
// SyncDownloadManager::Report
//===============================================================================================================

/*!
 *  @class SyncDownloadManager::Report
 *
 *  @brief The SyncDownloadManager::Report class details the outcome of processing a SyncDownloadManager queue.
 *
 *  @todo The constructors for this class will likely be made private (since they are meant to be generated by
 *  SyncDownloadManager), or a more general download report class that applies to multiple other network
 *  classes/functions will replace this.
 */

//-Constructor-------------------------------------------------------------------------------------------------------
//Public:
/*!
 *  Constructs a report noting a successful finish.
 */
SyncDownloadManager::Report::Report() : mFinishStatus(FinishStatus::Success) {}

/*!
 *  Constructs a report with the given @a finishStatus and @a errorInfo.
 */
SyncDownloadManager::Report::Report(FinishStatus finishStatus, GenericError errorInfo) :
    mFinishStatus(finishStatus),
    mErrorInfo(errorInfo)
{}

//-Instance Functions------------------------------------------------------------------------------------------------
//Public:
/*!
 *  Returns the finish status of the synchronous download manager this report came from.
 */
SyncDownloadManager::FinishStatus SyncDownloadManager::Report::finishStatus() const { return mFinishStatus; }

/*!
 *  Returns detailed error information from the report if the manager's downloads did not complete successfully;
 *  otherwise returns an invalid error.
 */
GenericError SyncDownloadManager::Report::errorInfo() const { return mErrorInfo; }

/*!
 *  Returns @c true if the manager's downloads did not complete successfully; otherwise returns @c false.
 */
bool SyncDownloadManager::Report::wasSuccessful() const { return mFinishStatus == FinishStatus::Success; }

//===============================================================================================================
// SyncDownloadManager
//===============================================================================================================

/*!
 *  @class SyncDownloadManager
 *
 *  @brief The SyncDownloadManager class is used to queue and process one or more downloads in a synchronous
 *  manner.
 *
 *  A synchronous download manager can process an arbitrary number of download tasks while tracking overall
 *  progress, forwarding events that require user interaction, and optionally controlling the maximum number
 *  of simultaneous downloads.
 *
 *  @warning This class currently does not support handling downloads that require pre-shared key authentication.
 *
 *  @note This class internally spins its own event loop in order to keep signals & slots processing while still
 *  blocking execution in the thread that contains the manager.
 *
 *  @sa DownloadTask
 */

//-Class Enums--------------------------------------------------------------------------------------------------------
//Public:
/*!
 *  @enum SyncDownloadManager::FinishStatus
 *
 *  This enum describes the reason that the synchronous download manager finished processing.
 */

/*!
 *  @var SyncDownloadManager::FinishStatus SyncDownloadManager::FinishStatus::Success
 *  The download task queue was processed successfully.
 */

/*!
 *  @var SyncDownloadManager::FinishStatus SyncDownloadManager::FinishStatus::UserAbort
 *  Processing was aborted by the user.
 */

/*!
 *  @var SyncDownloadManager::FinishStatus SyncDownloadManager::FinishStatus::AutoAbort
 *  Processing was aborting automatically after a download failed.
 */

/*!
 *  @var SyncDownloadManager::FinishStatus SyncDownloadManager::FinishStatus::Error
 *  Processing failed due to an error.
 */

//-Constructor-------------------------------------------------------------------------------------------------------
//Public:
/*!
 *  Constructs an empty synchronous download manager with parents @a parent.
 */
SyncDownloadManager::SyncDownloadManager(QObject* parent) : QObject(parent)
{
    // Configure access managers
    mDownloadAccessMan.setAutoDeleteReplies(true);
    mQueryAccessMan.setAutoDeleteReplies(true);
    mDownloadAccessMan.setRedirectPolicy(mRedirectPolicy);
    mQueryAccessMan.setRedirectPolicy(mRedirectPolicy);

    // Connect slots
    connect(&mDownloadAccessMan, &QNetworkAccessManager::finished, this, &SyncDownloadManager::downloadFinished);
    connect(&mDownloadAccessMan, &QNetworkAccessManager::sslErrors, this, &SyncDownloadManager::sslErrorHandler);
    connect(&mDownloadAccessMan, &QNetworkAccessManager::authenticationRequired, this, &SyncDownloadManager::authHandler);
    connect(&mDownloadAccessMan, &QNetworkAccessManager::proxyAuthenticationRequired, this, &SyncDownloadManager::proxyAuthHandler);

    connect(&mQueryAccessMan, &QNetworkAccessManager::sslErrors, this, &SyncDownloadManager::sslErrorHandler);
    connect(&mQueryAccessMan, &QNetworkAccessManager::authenticationRequired, this, &SyncDownloadManager::authHandler);
    connect(&mQueryAccessMan, &QNetworkAccessManager::proxyAuthenticationRequired, this, &SyncDownloadManager::proxyAuthHandler);
}

//-Instance Functions------------------------------------------------------------------------------------------------
//Private:
NetworkReplyError SyncDownloadManager::enumerateTotalSize()
{
    // Check size of each file
    for(const DownloadTask& task : qAsConst(mPendingDownloads))
    {
        // Get download size
        qint64 singleFileSize = 0;
        NetworkReplyError errorStatus = queryFileSize(singleFileSize, task.target);

        // Check for network error
        if(errorStatus.isValid())
            return errorStatus;

        // Add to total size
        mTotalBytes.setValue(task, singleFileSize);
    }

    // Emit calculated total
    emit downloadTotalChanged(mTotalBytes.total());

    // Return no error
    return NetworkReplyError();
}

NetworkReplyError SyncDownloadManager::queryFileSize(qint64& returnBuffer, QUrl target)
{
    // Ensure return buffer is reset
    returnBuffer = 0;

    // Event loop for waiting and error status holder
    QEventLoop sizeCheckWait;

    // Create and send size request
    QNetworkRequest sizeReq(target);
    sizeReq.setAttribute(QNetworkRequest::RedirectPolicyAttribute, mRedirectPolicy);
    QNetworkReply* sizeReply = mQueryAccessMan.head(sizeReq);

    // Result handler lambda
    connect(sizeReply, &QNetworkReply::finished, this, [&]()
    {
        // clazy lamda warnings are disabled since the outer function can never return without this lamda being called

        // Set size return buffer
        if(sizeReply->error() == QNetworkReply::NoError) // clazy:exclude=lambda-in-connect
            returnBuffer = sizeReply->header(QNetworkRequest::ContentLengthHeader).toLongLong();

        // End wait loop
        sizeCheckWait.quit(); // clazy:exclude=lambda-in-connect
    });

    // Stall until request is finished
    sizeCheckWait.exec();

    // Return error status
    return NetworkReplyError(sizeReply, target);
}

IoOpReport SyncDownloadManager::startDownload(DownloadTask task)
{
    // Create file handle
    QFile* file = new QFile(task.dest, this); // Parent constructor ensures deletion when 'this' is deleted

    // Create stream writer
    WriteOptions wo = WriteOption::CreatePath;
    if(!mOverwrite)
        wo |= WriteOption::NewOnly;
    std::shared_ptr<FileStreamWriter> fileWriter = std::make_shared<FileStreamWriter>(file, WriteMode::Truncate, wo);

    // Open file
    IoOpReport streamOpen = fileWriter->openFile();
    if(!streamOpen.wasSuccessful())
        return streamOpen;

    // Start download
    QNetworkRequest downloadReq(task.target);
    downloadReq.setAttribute(QNetworkRequest::RedirectPolicyAttribute, mRedirectPolicy);
    QNetworkReply* reply = mDownloadAccessMan.get(downloadReq);

    // Connect reply to support slots
    connect(reply, &QNetworkReply::readyRead, this, &SyncDownloadManager::readyRead);
    connect(reply, &QNetworkReply::downloadProgress, this, &SyncDownloadManager::downloadProgressHandler);

    // Add to active list
    mActiveDownloads[reply] = fileWriter;

    // Add reply to task map
    mReplyTaskMap[reply] = task;

    // Return success
    return IoOpReport();
}

void SyncDownloadManager::cancelAll()
{
    // Remove pending downloads
    mPendingDownloads.clear();

    // Abort all remaining downloads
    QHash<QNetworkReply*, std::shared_ptr<FileStreamWriter>>::const_iterator i;
    for(i = mActiveDownloads.constBegin(); i != mActiveDownloads.constEnd(); i++)
        i.key()->abort();

    mActiveDownloads.clear();
}

void SyncDownloadManager::reset()
{
    // Reset state
    mPendingDownloads.clear();
    mActiveDownloads.clear();
    mReplyTaskMap.clear();
    mCurrentBytes.clear();
    mTotalBytes.clear();
    mFinishStatus = FinishStatus::Success;
}

//Public:
/*!
 *  Inserts @a task into the download queue.
 *
 *  If the same task is already present in the queue then this function does nothing.
 */
void SyncDownloadManager::appendTask(DownloadTask task)
{
    // Don't let the same task be added twice
    if(!mDownloading && !mPendingDownloads.contains(task))
        mPendingDownloads.append(task);
}

/*!
 *  Returns the number of allowed simultaneous downloads.
 *
 *  The default is 3.
 *
 *  @sa setMaxSimultaneous().
 */
int SyncDownloadManager::maxSimultaneous() const { return mMaxSimultaneous; }

/*!
 *  Returns the directory policy of the manager.
 *
 *  The default is QNetworkRequest::NoLessSafeRedirectPolicy.
 *
 *  @sa setRedirectPolicy().
 */
QNetworkRequest::RedirectPolicy SyncDownloadManager::redirectPolicy() const { return mDownloadAccessMan.redirectPolicy(); }

/*!
 *  Returns @c true if the manager is configured to overwrite local files that already exist;
 *  otherwise returns @c false.
 *
 *  The default is @c false.
 *
 *  @sa setOverwrite().
 */
bool SyncDownloadManager::isOverwrite() const { return mOverwrite; }

/*!
 *  Returns @c true if the manager is configured to automatically abort all downloads if one fails;
 *  otherwise returns @c false.
 *
 *  The default is @c false.
 *
 *  @sa setAutoAbort().
 */
bool SyncDownloadManager::isAutoAbort() const { return mAutoAbort; }

/*!
 *  Returns current number of download tasks remaining, which includes pending and active downloads.
 *
 *  @sa hasTasks().
 */
int SyncDownloadManager::taskCount() const { return mPendingDownloads.count() + mActiveDownloads.count(); }

/*!
 *  Returns @c true if the manager has tasks left to process; otherwise returns @c false.
 */
bool SyncDownloadManager::hasTasks() const { return taskCount() > 0; }

/*!
 *  Sets the number of allowed simultaneous downloads to @a maxSimultaneous.
 *
 *  A value less than one results in no limit
 *
 *  @sa maxSimultaneous().
 */
void SyncDownloadManager::setMaxSimultaneous(int maxSimultaneous) { mMaxSimultaneous = maxSimultaneous; }

/*!
 *  Sets the directory policy of the manager to @a redirectPolicy.
 *
 *  @sa redirectPolicy().
 */
void SyncDownloadManager::setRedirectPolicy(QNetworkRequest::RedirectPolicy redirectPolicy)
{
    mRedirectPolicy = redirectPolicy;
    mDownloadAccessMan.setRedirectPolicy(redirectPolicy);
    mQueryAccessMan.setRedirectPolicy(redirectPolicy);
}

/*!
 *  Configures the manager to overwrite existing local files that already exist if @a overwrite is @c true;
 *  otherwise the download task that maps to destination will be aborted.
 *
 *  @sa isOverwrite().
 */
void SyncDownloadManager::setOverwrite(bool overwrite) { mOverwrite = overwrite; }

/*!
 *  Configures the manager to automatically abort all downloads after a single failure on if @a autoAbort
 *  is @c true.
 *
 *  @sa isAutoAbort().
 */
void SyncDownloadManager::setAutoAbort(bool autoAbort) { mAutoAbort = autoAbort; }

/*!
 *  Starts processing the download queue and returns once the queue has been exhausted, a fatal error has
 *  occurred, or the processing has been aborted.
 *
 *  The signals of this class are used to communicate download progress or issues with downloads during
 *  this time.
 */
SyncDownloadManager::Report SyncDownloadManager::processQueue()
{
    // Ensure error state is cleared
    mErrorList.clear();

    // Ensure instance will reset when complete
    QScopeGuard resetGuard([this](){ reset(); }); // Need lambda since function is private

    // Set flag
    QScopedValueRollback guard(mDownloading, true);

    // Get total task size
    NetworkReplyError enumError = enumerateTotalSize();
    if(enumError.isValid())
        return Report(FinishStatus::Error, GenericError(GenericError::Error, ERR_ENUM_TOTAL_SIZE.arg(enumError.url().toString()), enumError.text()));

    // Add initial downloads
    for(int j = 0; j < mMaxSimultaneous && !mPendingDownloads.isEmpty() || mMaxSimultaneous < 1; j++)
        startDownload(mPendingDownloads.takeFirst());

    // Wait for downloads to finish
    mDownloadWait.exec();

    // Create final error message
    GenericError fe;

    switch(mFinishStatus)
    {
        case FinishStatus::Success:
            fe = GenericError();
            break;

        case FinishStatus::UserAbort:
            fe = GenericError(GenericError::Error, ERR_QUEUE_INCOMPL, ERR_OUTCOME_USER_ABORT);
            break;

        case FinishStatus::AutoAbort:
            fe = GenericError(GenericError::Error, ERR_QUEUE_INCOMPL, ERR_OUTCOME_AUTO_ABORT, "- " + mErrorList.join("\n- "));
            break;

        case FinishStatus::Error:
            fe = GenericError(GenericError::Error, ERR_QUEUE_INCOMPL, ERR_OUTCOME_FAIL, "- " + mErrorList.join("\n- "));
            break;
    }

    // Create report
    Report report(mFinishStatus, fe);

    // Return final report
    return report;
}

//-Slots----------------------------------------------------------------------------------------------------------
//Private:
void SyncDownloadManager::downloadProgressHandler(qint64 bytesCurrent, qint64 bytesTotal)
{
    // Get the object that called this slot
    QNetworkReply* senderNetworkReply = qobject_cast<QNetworkReply*>(sender());

    // Ensure the signal that triggered this slot belongs to the above class by checking for null pointer
    if(senderNetworkReply == nullptr)
        throw std::runtime_error("Pointer conversion to network reply failed");

    // Update total size if needed
    if(bytesTotal != 0)
    {
        DownloadTask taskOfReply = mReplyTaskMap.value(senderNetworkReply);
        if(mTotalBytes.value(taskOfReply) != bytesTotal)
        {
            mTotalBytes.setValue(taskOfReply, bytesTotal);
            emit downloadTotalChanged(mTotalBytes.total());
        }
    }

    // Update cumulative progress
    mCurrentBytes.setValue(senderNetworkReply, bytesCurrent);

    // Emit progress
    emit downloadProgress(mCurrentBytes.total());
}

void SyncDownloadManager::downloadFinished(QNetworkReply* reply)
{
    // Get writer
    std::shared_ptr<FileStreamWriter> fileWriter = mActiveDownloads[reply];

    // Close and delete file
    mActiveDownloads[reply]->closeFile();
    delete fileWriter->file();

    // Remove from active downloads
    mActiveDownloads.remove(reply);

    // Check for non-abort error
    if(reply->error() != QNetworkReply::NoError && reply->error() != QNetworkReply::OperationCanceledError)
    {
        mErrorList.append(ERR_GEN_FAIL.arg(reply->url().toString(), reply->errorString()));

        if(mAutoAbort)
        {
            mFinishStatus = FinishStatus::AutoAbort;
            cancelAll();
        }
        else
            mFinishStatus = FinishStatus::Error;
    }

    // Add next pending download if not aborting
    if(mFinishStatus != FinishStatus::AutoAbort && mFinishStatus != FinishStatus::UserAbort && !mPendingDownloads.isEmpty())
        startDownload(mPendingDownloads.takeFirst());
    else if(mPendingDownloads.isEmpty()) // Release wait loop if all downloads are finished
        mDownloadWait.quit();
}

void SyncDownloadManager::readyRead()
{
    // Get the object that called this slot
    QNetworkReply* senderNetworkReply = qobject_cast<QNetworkReply*>(sender());

    // Ensure the signal that triggered this slot belongs to the above class by checking for null pointer
    if(senderNetworkReply == nullptr)
        throw std::runtime_error("Pointer conversion to network reply failed");

    // Write available data
    std::shared_ptr<FileStreamWriter> writer = mActiveDownloads[senderNetworkReply];
    writer->writeRawData(senderNetworkReply->readAll());

    if(!writer->status().wasSuccessful())
    {
        mErrorList.append(ERR_GEN_FAIL.arg(senderNetworkReply->url().toString(), writer->status().outcome() + ": " + writer->status().outcomeInfo()));

        if(mAutoAbort)
        {
            mFinishStatus = FinishStatus::AutoAbort;
            cancelAll();
        }
        else
        {
            mFinishStatus = FinishStatus::Error;
            senderNetworkReply->abort();
        }
    }
}

void SyncDownloadManager::sslErrorHandler(QNetworkReply* reply, const QList<QSslError>& errors)
{
    // Create error message
    GenericError errMsg(GenericError::Warning, SSL_ERR.arg(reply->url().toString()), CONTINUE_QUES,
                        String::join(errors, [](const QSslError& err){ return err.errorString(); }, ENDL, LIST_ITEM_PREFIX));

    // Signal result
    bool abortDownload = true;

    // Emit signal for answer
    emit sslErrors(errMsg, &abortDownload);

    // Abort if desired
    if(abortDownload)
    {
        reply->abort();
        mErrorList.append(ERR_SINGLE_ABORT.arg(reply->url().toString()));
        mFinishStatus = FinishStatus::Error;
    }
    else
        reply->ignoreSslErrors();
}

void SyncDownloadManager::authHandler(QNetworkReply* reply, QAuthenticator* authenticator)
{
    // Signal result
    bool abortDownload = true;
    QString username = QString();
    QString password = QString();

    // Emit signal for answer
    emit authenticationRequired(PROMPT_AUTH.arg(reply->url().host()), &username, &password, &abortDownload);

    // Abort if desired
    if(abortDownload)
    {
        reply->abort();
        mErrorList.append(ERR_SINGLE_ABORT.arg(reply->url().toString()));
        mFinishStatus = FinishStatus::Error;
    }
    else
    {
        authenticator->setUser(username);
        authenticator->setPassword(password);
    }
}

void SyncDownloadManager::proxyAuthHandler(const QNetworkProxy& proxy, QAuthenticator* authenticator)
{
    // Signal result
    bool abortDownload = true;
    QString username = QString();
    QString password = QString();

    // Emit signal for answer
    emit authenticationRequired(PROMPT_AUTH.arg(proxy.hostName()), &username, &password, &abortDownload);

    // Abort if desired
    if(abortDownload)
        abort();
    else
    {
        authenticator->setUser(username);
        authenticator->setPassword(password);
    }
}

//Public:
/*!
 *  Aborts all in-progress and remaining downloads immediately.
 *
 *  The finish status of the report returned from processQueue() is set to FinishStatus::UserAbort.
 */
void SyncDownloadManager::abort()
{
    if(!mActiveDownloads.isEmpty() || !mPendingDownloads.isEmpty())
    {
        mFinishStatus = FinishStatus::UserAbort;
        cancelAll();
    }
}

//-Signals------------------------------------------------------------------------------------------------
/*!
 *  @fn void SyncDownloadManager::downloadProgress(qint64 bytesCurrent)
 *
 *  This signal is emitted to indicate the progress of all downloads handled by the manager.
 *
 *  The @a bytesCurrent parameter indicates the total number of bytes received since queue processing was
 *  started.
 */

/*!
 *  @fn void SyncDownloadManager::downloadTotalChanged(quint64 bytesTotal)
 *
 *  This signal is emitted to indicate that total number of bytes required to complete all downloads has changed,
 *  with @a bytesTotal containing the new value.
 *
 *  This will always be emitted once just before the first batch of downloads are started after the size of all
 *  downloads in the queue has been requested, but may be emitted later when a download is started if the
 *  initially reported size was determined to be inaccurate.
 */

/*!
 *  @fn void SyncDownloadManager::sslErrors(Qx::GenericError errorMsg, bool* abort)
 *
 *  This signal is emitted if the SSL/TLS session encountered errors during the set up, including certificate
 *  verification errors. The errors parameter contains the list of errors.
 *
 *  To indicate that the errors are not fatal and that the connection should proceed, the @a abort parameter
 *  should be set to @c false; otherwise processing will be aborted.
 *
 *  This signal can be used to display an error message to the user indicating that security may be compromised and
 *  display the SSL settings (see sslConfiguration() to obtain it).
 *
 *  See also QNetworkAccessManager::sslErrors().
 */

/*!
 *  @fn void SyncDownloadManager::authenticationRequired(QString prompt, QString* username, QString* password, bool* abort)
 *
 *  This signal is emitted whenever a final server requests authentication before it delivers the requested contents, or
 *  a proxy requests authentication, with @a prompt indicating which.
 *
 *  The slot connected to this signal should provide the requested credentials via @a username and @a password and set
 *  @a abort to false, or else processing will be aborted. If no slots are connected to this signal then downloads
 *  that require authentication will always cause the manager to abort.
 *
 *  The manager caches the provided credentials internally and will send the same values if the server requires
 *  authentication again, without emitting the authenticationRequired() signal. If it rejects the credentials, this
 *  signal will be emitted again.
 */
}
